// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array                = require("bs-platform/lib/js/array.js");
var Block                  = require("bs-platform/lib/js/block.js");
var Curry                  = require("bs-platform/lib/js/curry.js");
var Pervasives             = require("bs-platform/lib/js/pervasives.js");
var Caml_oo_curry          = require("bs-platform/lib/js/caml_oo_curry.js");
var CamlinternalOO         = require("bs-platform/lib/js/camlinternalOO.js");
var Core$Sweenyville       = require("./core.bs.js");
var Reasonable$Sweenyville = require("../lib/reasonable.bs.js");

var class_tables = [
  0,
  0,
  0
];

function MakeGameObject(ObjectType) {
  var spawn = function (param, param$1, hub) {
    if (!class_tables[0]) {
      var $$class = CamlinternalOO.create_table([
            "data",
            "tick",
            "turn",
            "decel",
            "direction",
            "accel",
            "category"
          ]);
      var env = CamlinternalOO.new_variable($$class, "");
      var ids = CamlinternalOO.new_methods_variables($$class, [
            "turn",
            "tick",
            "setSpeedIf",
            "direction",
            "decel",
            "data",
            "category",
            "accel"
          ], [
            "direction",
            "data",
            "maxSpeed"
          ]);
      var turn = ids[0];
      var tick = ids[1];
      var setSpeedIf = ids[2];
      var direction = ids[3];
      var decel = ids[4];
      var data = ids[5];
      var category = ids[6];
      var accel = ids[7];
      var direction$1 = ids[8];
      var data$1 = ids[9];
      var maxSpeed = ids[10];
      CamlinternalOO.set_methods($$class, /* array */[
            category,
            (function (self$1) {
                return self$1[env][0][/* category */0];
              }),
            turn,
            (function (self$1, d) {
                if (d === 3 || d === 2) {
                  self$1[direction$1][0] = d;
                  return /* () */0;
                } else {
                  return /* () */0;
                }
              }),
            direction,
            (function (self$1, _) {
                return self$1[direction$1][0];
              }),
            tick,
            (function (self$1, scene) {
                var env$1 = self$1[env];
                var match_000 = self$1[data$1][/* x */0];
                var match_001 = self$1[data$1][/* y */1];
                var current_y = match_001;
                var current_x = match_000;
                var match = Curry._3(env$1[0][/* next_coordinates */1], scene, /* tuple */[
                      self$1[data$1][/* x */0],
                      self$1[data$1][/* y */1]
                    ], /* tuple */[
                      self$1[data$1][/* vx */2],
                      self$1[data$1][/* vy */3]
                    ]);
                self$1[data$1][/* x */0] = match[0];
                self$1[data$1][/* y */1] = match[1];
                var init = self$1[data$1];
                var previous_state = /* float array */[
                  current_x,
                  current_y,
                  init[/* vx */2],
                  init[/* vy */3],
                  init[/* height */4],
                  init[/* width */5]
                ];
                var colliders = Curry._2(env$1[0][/* colliders */4], self$1, Caml_oo_curry.js2(-746899837, 2, scene, /* () */0));
                return $$Array.iter((function (c) {
                              Curry._2(env$1[1][/* trigger */3], /* Collided */1, /* Collision */Block.__(1, [
                                      self$1,
                                      c,
                                      previous_state
                                    ]));
                              if (Core$Sweenyville.above(previous_state, c) || Core$Sweenyville.below(previous_state, c)) {
                                self$1[data$1][/* vy */3] = 0.0;
                                self$1[data$1][/* y */1] = current_y;
                              }
                              if (Core$Sweenyville.right_of(previous_state, c) || Core$Sweenyville.left_of(previous_state, c)) {
                                self$1[data$1][/* vx */2] = 0.0;
                                self$1[data$1][/* x */0] = current_x;
                                return /* () */0;
                              } else {
                                return 0;
                              }
                            }), colliders);
              }),
            accel,
            (function (self$1, direction) {
                var match = Curry._3(self$1[env][0][/* accel */2], direction, /* tuple */[
                      self$1[data$1][/* vx */2],
                      self$1[data$1][/* vy */3]
                    ], self$1[maxSpeed]);
                return Curry._4(self$1[0][setSpeedIf], self$1, /* true */1, match[0], match[1]);
              }),
            decel,
            (function (self$1, direction) {
                var match = Curry._3(self$1[env][0][/* decel */3], direction, self$1[data$1][/* vx */2], self$1[data$1][/* vy */3]);
                return Curry._4(self$1[0][setSpeedIf], self$1, match[0], match[1], match[2]);
              }),
            data,
            (function (self$1, _) {
                var match = self$1[data$1];
                var x = match[/* x */0];
                var y = match[/* y */1];
                var vx = match[/* vx */2];
                var vy = match[/* vy */3];
                var height = match[/* height */4];
                var width = match[/* width */5];
                return /* float array */[
                        x,
                        y,
                        vx,
                        vy,
                        height,
                        width
                      ];
              }),
            setSpeedIf,
            (function (self$1, going, vx, vy) {
                if (going) {
                  self$1[data$1][/* vx */2] = vx;
                  self$1[data$1][/* vy */3] = vy;
                  return /* () */0;
                } else {
                  return 0;
                }
              })
          ]);
      var env_init = function (env$1) {
        var self = CamlinternalOO.create_object_opt(0, $$class);
        self[direction$1] = [/* Nowhere */4];
        self[data$1] = /* float array */[
          env$1[1],
          env$1[2],
          0.0,
          0.0,
          env$1[4],
          env$1[3]
        ];
        self[maxSpeed] = 8.0;
        self[env] = env$1[0];
        return self;
      };
      CamlinternalOO.init_class($$class);
      class_tables[0] = env_init;
    }
    return Curry._1(class_tables[0], [
                [
                  ObjectType,
                  hub
                ],
                param[0],
                param[1],
                param$1[0],
                param$1[1]
              ]);
  };
  return /* module */[/* spawn */spawn];
}

function next_coordinates(scene, position, speed) {
  var new_x = Pervasives.max(Caml_oo_curry.js2(761282246, 4, scene, /* () */0), Pervasives.min(Caml_oo_curry.js2(-405516197, 3, scene, /* () */0), position[0] + speed[0]));
  var new_y = Pervasives.max(Caml_oo_curry.js2(-963970092, 6, scene, /* () */0), Pervasives.min(Caml_oo_curry.js2(-146710358, 5, scene, /* () */0), position[1] + speed[1]));
  return /* tuple */[
          new_x,
          new_y
        ];
}

function accel(direction, speed, maxSpeed) {
  var vy = speed[1];
  var vx = speed[0];
  switch (direction) {
    case 0 : 
        return /* tuple */[
                vx,
                Pervasives.max(vy - 0.2, 0.0 - maxSpeed)
              ];
    case 1 : 
        return /* tuple */[
                vx,
                Pervasives.min(vy + 0.2, maxSpeed)
              ];
    case 2 : 
        return /* tuple */[
                Pervasives.max(vx - 0.2, 0.0 - maxSpeed),
                vy
              ];
    case 3 : 
        return /* tuple */[
                Pervasives.min(vx + 0.2, maxSpeed),
                vy
              ];
    case 4 : 
        return /* tuple */[
                vx,
                vy
              ];
    
  }
}

function decel(direction, vx, vy) {
  switch (direction) {
    case 0 : 
        return /* tuple */[
                +(vy < 0.0),
                vx,
                Pervasives.min(vy + 0.2, 0.0)
              ];
    case 1 : 
        return /* tuple */[
                +(vy > 0.0),
                vx,
                Pervasives.max(vy - 0.2, 0.0)
              ];
    case 2 : 
        return /* tuple */[
                +(vx < 0.0),
                Pervasives.min(vx + 0.2, 0.0),
                vy
              ];
    case 3 : 
        return /* tuple */[
                +(vx > 0.0),
                Pervasives.max(vx - 0.2, 0.0),
                vy
              ];
    case 4 : 
        return /* tuple */[
                /* false */0,
                vx,
                vy
              ];
    
  }
}

function colliders(obj, renderables) {
  return Reasonable$Sweenyville.select(renderables, (function (r) {
                if (r !== obj) {
                  return Core$Sweenyville.collision(r, obj);
                } else {
                  return /* false */0;
                }
              }));
}

exports.MakeGameObject   = MakeGameObject;
exports.next_coordinates = next_coordinates;
exports.accel            = accel;
exports.decel            = decel;
exports.colliders        = colliders;
/* No side effect */
